### 어플리케이션 계층에서 배운 RDT를 한번에 하나씩 보내면 굉장한 비효율
### 따라서, 한번에 많은 패킷 보내는 방법이 필요함

<br>

---

<br>

# Go-Back-N (GBN)
- 윈도우 크기 n만큼, ack안기다리고 순서대로 보낸다
- 송신오류가 나면, 오류가 난 시퀀스#에서 수신을 멈추고 ark를 보낸다.
- 오류가 난 패킷 시퀀스로 돌아가서, 거기부터 다시보낸다 (go back n)

<br>

#### 문제점 : 다시 돌아가서 거기부터 다시보내는게 비효율적이다
#### 해결책 : 오류난 패킷만 다시보낸다. (selective Repeat)

<br>

---

<br>

# Selective Repeat
- 송신측에서 윈도우 크기 n만큼 보낸다
- 수신측에서 손실된 패킷 빼고, 각각 다 ack를 보내주며 버퍼(윈도우 크기)에 저장한다
- 송신측에서 손실된거 time-out이 되어 재전송한다
- 수신측에서 손실된 패킷도 받아서 버퍼가 다 채워지면, 패킷을 순서 맞춰서 상위 계층에 전달한다
<br>

#### 문제점 : ack가 손실돼서 재전송된 패킷0과, ack가 제대로 와서 보내는 새로운 패킷0이 구분이 안된다.
#### 해결책 : 시퀀스#의 범위가 윈도우 크기보다 최소 2배가 되게 한다

<br>

---

<br>

# TCP 개요
- 점대점 통신 : 샌더 하나에 리시버 하나만 연결
- 신뢰할 수 있고, 순서가 보장
- 파이프라인 전송 : 윈도우 크기 설정하고 한번에 여러 패킷 전송
- 송신 및 수신 버퍼 : 윈도우 크기만큼 버퍼에 저장해놓고 씀
- 양방향 통신 : 소켓 하나가 송신도 하고 수신도 함. 버퍼도 소켓 하나에 송신버퍼, 수신버퍼 따로 있음
- 연결 지향형 : 핸드 셰이킹
- 흐름제어(flow control) : 수신자가 처리할 수 있는 만큼만 데이터 송신 (과부하 방지)
# 타임아웃
- 패킷 손실 여부를 타임아웃으로 판단
### TCP 타임아웃 설정 방법
- 타임이 너무 짧으면 불필요한 재전송, 너무 길면 리커버리 속도가 늦음
- RTT (Round Trip Time) : 패킷이 왕복하는데 걸리는 시간
- SampleRTT : 세그먼를 전송한 후 ack를 받기까지의 시간을 측
- EstimatedRTT : SampleRTT는 매번 다르게 나오니, 측정값들을 평균
- TimeoutInterver : EstimatedRTT로 하면 타임아웃이 많이 발생하니, EstimatedRTT에 마진(DevRTT)를 더해줘서 넉넉하게 잡는다.
### TCP 타이머
- TCP는 타이머를 1개사용 (이 부분은 go-bakc-n과 비슷)
- 가장 오래된 unacked 세그먼트를 기준으로 타이머가 돌아감
- 타임아웃시, 타임아웃된 곳으로 send base가 되돌아가지 않고, 타임아웃 된것만 재전송함 (이 부분은 go-back-n과 다름)
- cumulative ack : sender가 ack를 받으면, 그 이전 seq#들의 ack를 못받았어도, 그 seq#들이 잘 전송되었다고 판단
  ### fast retransmit
  - 타임아웃 되기전에 중복ack를 3번 받으면, 타임아웃을 기다리지 않고 재전송
    - 중복ack 3번 = 같은 ack를 4번 받은 것
  - 타이머는 꼭 필요하지만, fast retransmit은 꼭 필요한건 아니고 그저 효율을 위해 존재
# 흐름 제어 (Flow Control)
- 리시버 버퍼의 data를 어플리케이션 계층에서 가져감
- 버퍼에 여유 공간(spare room)이 생김
- 리시버 버퍼에 여유 공간이 얼마나 있는지, segment 헤더에 실어서 보냄
- 그 공간에 맞춰, sender가 보내는 data양을 조절하는 것이 flow contorl
# TCP 연결 관리 (Connection Management)
### 3-way handshake
1. 송신자 전송 SYNbit = 1, seq = x
2. 수신자 전송 SYNbit = 1, seq = y, ACKbit = 1, ACKnum = x+1
3. 송신자 전송 ACKbit = 1, ACKnum = y+1 (데이터 포함 가능)
### HTTP (3-way handshake)
1. 클라이언트 TCP 연결 시작
2. 서버 TCP 연결 수락
3. 클라이언트 HTTP req (데이터 포함)
