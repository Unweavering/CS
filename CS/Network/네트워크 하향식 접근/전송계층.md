### 어플리케이션 계층에서 배운 RDT를 한번에 하나씩 보내면 굉장한 비효율
### 따라서, 한번에 많은 패킷 보내는 방법이 필요함

<br>

---

<br>

# Go-Back-N (GBN)
- 윈도우 크기 n만큼, ack안기다리고 순서대로 보낸다
- 송신오류가 나면, 오류가 난 시퀀스#에서 수신을 멈추고 ark를 보낸다.
- 오류가 난 패킷 시퀀스로 돌아가서, 거기부터 다시보낸다 (go back n)

<br>

#### 문제점 : 다시 돌아가서 거기부터 다시보내는게 비효율적이다
#### 해결책 : 오류난 패킷만 다시보낸다. (selective Repeat)

<br>

---

<br>

# Selective Repeat
- 송신측에서 윈도우 크기 n만큼 보낸다
- 수신측에서 손실된 패킷 빼고, 각각 다 ack를 보내주며 버퍼(윈도우 크기)에 저장한다
- 송신측에서 손실된거 time-out이 되어 재전송한다
- 수신측에서 손실된 패킷도 받아서 버퍼가 다 채워지면, 패킷을 순서 맞춰서 상위 계층에 전달한다
<br>

#### 문제점 : ack가 손실돼서 재전송된 패킷0과, ack가 제대로 와서 보내는 새로운 패킷0이 구분이 안된다.
#### 해결책 : 시퀀스#의 범위가 윈도우 크기보다 최소 2배가 되게 한다

<br>

---

<br>

# TCP 개요
- 점대점 통신 : 샌더 하나에 리시버 하나만 연결
- 신뢰할 수 있고, 순서가 보장
- 파이프라인 전송 : 윈도우 크기 설정하고 한번에 여러 패킷 전송
- 송신 및 수신 버퍼 : 윈도우 크기만큼 버퍼에 저장해놓고 씀
- 양방향 통신 : 소켓 하나가 송신도 하고 수신도 함. 버퍼도 소켓 하나에 송신버퍼, 수신버퍼 따로 있음
- 연결 지향형 : 핸드 셰이킹
- 흐름제어 : 수신자가 처리할 수 있는 만큼만 데이터 송신 (과부하 방지)
## 타임아웃
- 패킷 손실 여부를 타임아웃으로 판단
### TCP 타임아웃 설정 방법
- 타임이 너무 짧으면 불필요한 재전송, 너무 길면 리커버리 속도가 늦음
- RTT (Round Trip Time) : 패킷이 왕복하는데 걸리는 시간
- 타임아웃은 RTT보다 길어야 한다
- 타임아웃이 RTT로 타이트하게 하면, 타임아웃이 많이 발생하니, 편차를 반영하여 넉넉하게 잡는다
