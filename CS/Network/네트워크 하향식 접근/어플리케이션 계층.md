# 소켓
- 클라이언트 프로세스와 서버 프로세스간의 통신을 위해, OS가 제공하는 일종의 API
- 어플리케이션 계층 밑의 계층들이 OS 내부에 구현되어 있음
- OS가 제공하는 Transport계층 : TCP/UDP 
- TCP를 하고싶으면 TCP와 연결된 소켓을 이용, UDP는 UDP와 연결된 소켓을 이용
- 즉, 소켓은 어플리케이션 계층과 OS 사이의 인터페이스

<br>

### TCP
- SOCK_STREAM

<br>

### UDP
- SOCK_DGRAM

<br>

# <TCP 소켓함수>
 ## socket()
 - 소켓 생성
 - 소켓 **파일 디스크립트**(인덱스) 반환
 - 파라미터 : TCP/UDP 설정
 
 ## bind()
 - 소켓을 ip,포트넘버에 바인딩
 - (소켓 파일 디스크립트를 이용해서 바인딩)
 
 ## listen()
 - 소켓을 수동상태(passive state)로 만든다
 - ****수동상태**** : 클라이언트의 연결을 기다리는 상태
 - **non-blocking** : 함수 즉시 반환, 다른 작업 수행 가능
 - 파라미터 : 연결 대기열(큐)의 크기 설정
 
 ## accept()
 - 클라이언트의 연결을 수락
 - 그 연결을 처리할 소켓을 생성
 - 생성된 소켓의 파일 디스크립터를 반환
 - **blocking 함수** : 함수가 완료될 때까지 실행이 멈춤
  참고 : 수동상태로 클라이언트의 연결을 대기하는 소켓은 계속 그 역할을 하고, accept()에서 새로 생성한 소켓이 클라이언트와 연결되는 것이다.
 ## connect()
 - 서버에 연결 요청
 - **blocking 함수**
  #### 참고
  - 서버는 포트넘버 80같은곳에 지정해야 되서 bind()를 쓰지만, 클라이언트틑 그럴필요가 없다
  - 그래서 보통 클라이언트는 bind()를 쓰지 않고, connect()를 쓸 떄 ip와 포트넘버가 자동 할당된다.
 ## write()
 - 소켓을 통해 데이터르 보냄
 - Blocking 함수
 ## read()
 - 소켓을 통해 데이터를 읽음
 - Blocking 함수
 ## 포트 릴리즈
  - 컨트롤 c처럼 프로그램이 비정상(rough) 종료 됐을 때, 포트가 즉시 해제가 안됨
  - singal같은 라이브러리 쓰면 즉시 포트 해제(release)되게 할 수 있음

<br>

# Multiplexing/Demultiplexing
### Multiplexing
- 여러 소켓에서 데이터를 수집
- 수집된 데이터에 헤더를 묶어서 segment로 만듬

### Demultiplexing
- 수신된 segment를 적절한 소켓으로 전달
- (헤더 정보를 활용하여 적절한 소켓을 찾음)

<br>

### UDP의 경우
- dest IP
- dest port
- 이 2가지로 목적지 소켓 찾음
- 하나의 dest에 여러개의 src가 연결됨

### TCP의 경우
- dest IP
- dest port
- src IP
- src port
- 이 4가지로 목적지 소켓 찾음
- 하나의 dest 소켓엔 하나의 src 소켓만 연결됨
- 그래서  connected 임

### ex) 네이버
- 사용자가 네이버에 접속 (TCP)
- 네이버에서 사용자가 하나 접속할 때마다, 소켓을 하나 생성
- 하나의 dest 소켓엔 하나의 src만 연결되기 때문

<br>

 # UDP segment
- src port : 16비트 : 65536개
- dest port : 16비트
- length
- checksum : 에러체크, 에러있으면 드랍시킴
  ### UDP
  - 멀티플렉싱/디멀티플렉싱
  - 에러체킹
