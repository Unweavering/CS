# 소켓
- 클라이언트 프로세스와 서버 프로세스간의 통신을 위해, OS가 제공하는 일종의 API
- 어플리케이션 계층 밑의 계층들이 OS 내부에 구현되어 있음
- OS가 제공하는 Transport계층 : TCP/UDP 
- TCP를 하고싶으면 TCP와 연결된 소켓을 이용, UDP는 UDP와 연결된 소켓을 이용
- 즉, 소켓은 어플리케이션 계층과 OS 사이의 인터페이스

<br>

### TCP
- SOCK_STREAM

<br>

### UDP
- SOCK_DGRAM

<br>

# <TCP 소켓함수>
## socket()
- 소켓 생성
- 소켓 **파일 디스크립트**(인덱스) 반환
- 파라미터 : TCP/UDP 설정

## bind()
- 소켓을 ip,포트넘버에 바인딩
- (소켓 파일 디스크립트를 이용해서 바인딩)

## listen()
- 소켓을 수동상태(passive state)로 만든다
- ****수동상태**** : 클라이언트의 연결을 기다리는 상태
- **non-blocking** : 함수 즉시 반환, 다른 작업 수행 가능
- 파라미터 : 연결 대기열(큐)의 크기 설정

## accept()
- 클라이언트의 연결을 수락
- 그 연결을 처리할 소켓을 생성
- 생성된 소켓의 파일 디스크립터를 반환
- **blocking 함수** : 함수가 완료될 때까지 실행이 멈춤

참고 : 수동상태로 클라이언트의 연결을 대기하는 소켓은 계속 그 역할을 하고, accept()에서 새로 생성한 소켓이 클라이언트와 연결되는 것이다.
## connect()
- 서버에 연결 요청
- **blocking 함수**

<br>

#### 참고
- 서버는 포트넘버 80같은곳에 지정해야 되서 bind()를 쓰지만, 클라이언트틑 그럴필요가 없다
- 그래서 보통 클라이언트는 bind()를 쓰지 않고, connect()를 쓸 떄 ip와 포트넘버가 자동 할당된다.
## write()
- 소켓을 통해 데이터르 보냄
- Blocking 함수
## read()
- 소켓을 통해 데이터를 읽음
- Blocking 함수

  <br>

 # 포트 릴리즈
  - 컨트롤 c처럼 프로그램이 비정상(rough) 종료 됐을 때, 포트가 즉시 해제가 안됨
  - singal같은 라이브러리 쓰면 즉시 포트 해제(release)되게 할 수 있음

<br>

# Multiplexing
- 여러 소켓에서 데이터를 수집
- 수집된 데이터에 헤더를 묶어서 segment로 만듬

# Demultiplexing
- 수신된 segment의 header를 확인해, segment를 전달받을 적절한 소켓을 찾음
- 적절한 소켓으로 segment를 전달
